<!-- https://rosettacode.org/wiki/Variables -->
=={{header|Diego}}==
===Declaration===
Declaration of variables is required by the caller with the original source of the variable.  If a callee hears of a variable after a declaration, it can ask around or ask the caller for the declaration; ignore the variable and any instructions associated with it; or try to determine the context and/or the callers intentions. I suppose this depends upon the mood of the callee.

<b>syntax:</b>

Use <code>add_var</code> verb-object (short for 'add variable') or the <code>dim</code> action (short for 'dimension of'):

<code>add_var(<i>variablename</i>);</code> or <code>dim(<i>variablename</i>);</code>

...multiple variables can de declared in a comma separated list.
<!-- <code>add_var(<i>variablename1</i>, <i>variablename2</i>, <i>variablename3</i>, <i>...</i>);</code> or <code>dim(<i>variablename1</i>, <i>variablename2</i>, <i>variablename3</i>, <i>...</i>);</code> -->

With no datatype specified, the variables are of variant type (as in basic'esque languages).  Datatypes are specified using the <code>_datatype_</code> posit (can be shortened to <code>_dt</code>):

<code>add_var(<i>variablename</i>)_datatype(<i>datatype</i>);</code> or <code>dim(<i>variablename</i>)_dt(<i>datatype</i>);</code>
<!-- <code>add_var(<i>variablename</i>)_dt(<i>datatype</i>);</code> or <code>dim(<i>variablename</i>)_datatype(<i>datatype</i>);</code> -->

...or using the <code>{}</code> braces:

<code>add_var({<i>datatype</i>}, <i>variablename</i>);</code> or <code>dim({<i>datatype</i>}, <i>variablename</i>);</code>
<!-- <code>add_var({<i>datatype</i>}, <i>variablename1</i>, <i>variablename2</i>, <i>variablename3</i>, ...);</code> or <code>dim({<i>datatype</i>}, <i>variablename1</i>, <i>variablename2</i>, <i>variablename3</i>, <i>...</i>);</code>
<code>add_var({<i>datatype</i>}, <i>variablename1</i>, {<i>datatype</i>}, <i>variablename2</i>, {<i>datatype</i>}, <i>variablename3</i>, <i>...</i>);</code> or <code>dim({<i>datatype</i>}, <i>variablename1</i>, {<i>datatype</i>}, <i>variablename2</i>, {<i>datatype</i>}, <i>variablename3</i>, ...);</code> -->

<b>examples:</b>

<lang diego>add_var(v1);
dim(v1);
add_var(v1, v2, v3, v4);
dim(v1, v2, v3, v4);
add_var(isRaining)_datatype(boolean);
dim(isRaining)_datatype(boolean);
add_var(greeting)_dt(string);
dim(greeting)_dt(string);
add_var({date}, birthdate);
dim({date}, birthdate);</lang>

Variables can also be declared at posit state.  So, verb-object <code>add_var</code> becomes posits <code>_addvar</code> or, shortened, <code>_var</code>; action <code>dim</code> becomes a posit. So, for example, during a robot manoeuvre a variable can be declared:

<lang deigo>go_robot(alif)_waypoint(waypoint1)_addvar({bool},alifArriveWaypoint1);
go_robot(beh)_waypoint(waypoint1)_var({bool},behArriveWaypoint1);
go_robot(teh)_waypoint(waypoint1)_dim({bool},tehArriveWaypoint1);</lang>

===Initialisation===
Initialisation of variables can exist at declaration (using posit <code>_value</code> or, the shortened <code>_v</code>) or after declaration (using <code>with_var</code> then <code>_value</code>).  <!--After declaration variables can be also referenced using <code>()</code> brackets.  -->The first time the <code>_value</code> posit is used is the initialisation.

<b>syntax:</b>

<code>add_var<i>...</i>_value(<i>value</i>);</code>

<code>dim<i>...</i>_v(<i>value</i>);</code>

<!-- <code>(<i>variablename</i>)_value(<i>value</i>);</code> -->

<b>examples:</b>

Initialisation at declaration:
<lang diego>add_var({integer},wholeNumber1,wholeNumber2)_value(3);
dim({double},realNumber)_v(3.0);
add_var({boolean},isRaining)_v(false);
add_var(greeting)_datatype(string)_value(Hello, this is World speaking.);</lang>

Initialisation after declaration:
<lang diego>with_var(birthdate)_value(24-Jun-1963);
[myinteger]_value(33);</lang>

Dynamic initialisation after declaration:
<lang diego>[myYearVar]_v(1963);
[datename]_v(24-Jun-[myYearVar]);</lang>

Variables that are not initialised are determined to be <code>undefined</code>. The callee can be sensitive to uninitialised (undefined) variables with its undefined sensitivity setting <code>set_undefined()_sensiti();</code>.  So, for instance, if a callee is sensitive to a undefined variable, it will ask the caller and others in the mist for the declaration of the variable with command <code>with_var(<i>variablename</i>)_askdec();</code>.

===Assignment===
Initialisation and assignment are the same, since the first assignment is the initialisation. Direct assignment of variables is achieved, as with the initialisation, using <code>_value</code> (or shortened <code>_v</code>) posit after the <code>with_var</code> verb-object or <code>[]</code> variable referencing brackets, as shown above.  Assignment of a variable with other variables and operators can be achieved using the <code>_calc</code> (short for 'calculation') posit.  Within the brackets of <code>_calc</code> the square brackets <code>[]</code> is be used to reference variables.

<b>syntax:</b>

<code>with_var(<i>variablename</i>)_calc(<i>expression/calculation</i>);</code>

<code>[<i>variablename</i>]_calc(<i>expression/calculation</i>);</code>

<b>examples:</b>

<lang diego>with_var(d)_calc([b]^2-4*[a]*[c]);
with_var(E)_calc([m]*[c]^2);
with_var(d)_calc([b]^2-4*[a]*[c]);</lang>
<!--(fullname)_calc([firstname]&" "&[lastname]);
(c)_calc(++);
([c])_calc(+=[a]);
([c]+[b]);</lang> -->

Note, instead of using the <code>_calc</code> posit, all operators can be also be posits, for example:

<lang diego>with_var(E)_equals(m)_multipl(c)_sq();  // E=mc²
with_var(c)_inc();  // increment by one
with_var(c)_inc(a);  // same as with_var(c)_exp(+=[a]);</lang>

<!-- <lang diego>(E)_equals(m)_multipl(c)_sq();  // E=mc²
(c)_inc();  // increment by one
(c)_inc(a);  // same as [c]_exp(+=[a]);</lang> -->

===Datatypes===
Datatypes in Diego are only implied by name following the general-purpose datatypes proposed in ISO/IEC 11404.  The datatype given in Diego code is presumed to be the datatype of the caller.  The callee will have to presume the datatype name from the caller is the same datatype of the same name by the callee.

<b>syntax:</b>

The syntax of declaring datatypes is achieved using the <code>_datatype</code> (or shortened <code>_dt</code>) posit.

<code>add_var<i>...</i>_datatype(<i>datatype</i>)<i>...</i></code>
<!-- <code>add_var<i>...</i>_dt(<i>datatype</i>)<i>...</i></code> -->

<!-- <code>dim<i>...</i>_datatype(<i>datatype</i>)<i>...</i></code> -->
<code>dim<i>...</i>_dt(<i>datatype</i>)<i>...</i></code>
    
A further shortened use of the <code>{}</code> brackets can be used inside declarations<!-- and assignments-->. 

<code>add_var({<i>datatype</i>},<i>variablename</i>)<!-- _value(<i>value</i>) -->;</code>

<code>dim({<i>datatype</i>},<i>variablename</i>)<!-- _value(<i>value</i>) -->;</code>
<!-- <code>add_var(<i>variablename</i>)_value({<i>datatype</i>}, <i>value</i>);</code>
<code>dim(<i>variablename</i>)_value({<i>datatype</i>}, <i>value</i>);</code> -->

<b>examples:</b>

<lang diego>add_var(wholeNumber)_datatype(integer);
dim({double},myNumber)_v(3.0);
with_var(wholenumber)_datatype(integer);
with_var({boolean},isRaining)_value(false); // cast/converting datatype</lang>
<!-- ({boolean},isRaining)_value(false); // cast/converting datatype</lang> -->

However, datatypes can be implied to be variables using verb-object and posit commands, as such:

<b>syntax:</b>

<code>add_str(<i>variablename</i>)_value(<i>value</i>)</code> to declare a string datatype.

<code>with_bool(<i>variablename</i>)_value(<i>value</i>)</code> to reference a boolean datatype, etc.

<code>_float([<i>variablename</i>]=<i>value</i>)</code> to declare an integer datatype in posit state.

<code>_int([<i>variablename</i>]),<i>variablename</i>)</code> to declare an integer datatype in posit state, etc.

<b>examples:</b>

<lang diego>add_str(bobName)_value(Bob);
alert_human(bob)_msg(Hi [bobName]);         // Hi Bob

alert_human(fred)_msg(Hi [fredName])_str(fredName)_value(Freddy);  // Hi Freddy</lang>

===Scope===
Variable scope is generally described a "public and interpreted" in Diego, as all variables are shared amongst thingys (humans, robots, and mobots). Every variable is 'public access', so scope is only achieved through <b>discernment</b>, <b>swarmation</b>, and <b>discrimination</b>.  The keyword <code>me</code> (used as an verb-action, action, or, posit) is used to keep discernment of other thingys for use of the variable.  The use of objects or criteria is used to discriminate against/for humans/robots/mobots.  Then excluding objects (or using other criteria) is used to swarmate humans/robots/mobots.

<b>For example:</b>

<lang diego>add_var(greeting)_value(Hello World)_me();</lang>

or

<lang diego>with_me()_var(greeting)_value(Hello World);</lang>

This command will share the variable <code>greeting</code> and its value with all thingys, but, the other thingys that received this command will not act upon it because they know this variable is for the exclusive use of the caller (<code>me</code>).  This is <b>discernment</b>.

However, the command...

<lang diego>add_var(greeting)_value(Hello World);</lang>

...will share and use the variable <code>greeting</code> and its value with all thingys that received this command. This is <b>swarmation</b>.

However, the command...

<lang diego>add_var(greeting)_value(Hello World)_for()_computer(cmp1);</lang>

...will share the variable <code>greeting</code> and its value with all thingys that received this command, but only the computer named <code>cmp1</code> will use/act upon this variable. This is <b>discrimination</b>.
<!--
<lang diego>with_robot(alif)_msg(Hello World);</lang>

...this command will display, via a media on <code>alif</code>'s choosing, the message "Hello World".  However,...

<lang diego>with_robot()_msg(Hello World);</lang>

...this command will display the message "Hello World" on every robot that receives the command.  However,...

<lang diego>with_computer()_msg(Hello World);</lang>

...this command will display the message "Hello World" on every computer that receives the command (but not any robots).  However,...

<lang diego>with_computer()_os(windows)_msg(Hello World);</lang>

...this command will display the message "Hello World" on every computer that is running Microsoft&reg; Windows&tm; that receives the command (but not any robots), and so on... -->

Scope also occurs within functions (<code>_funct</code> object in Diego); instructions (<code>_instruct</code> object in Diego); and, more, using the same approach with scope with variables.

There are also namespaces (using object <code>_namespace</code>, or, shortened, <code>_ns</code>) that contain the scope of variables, however, all variables are public inside the namespace, only differentiated between variables of the same signature (i.e. name and datatype).

===Referencing===
Referencing variables is achieved using the verb-object <code>with_var</code>, or implied <code>with_var</code> with the use of <code>()</code> and <code>[]</code> brackets, and combinations of.

When referencing variables the use of <code>()</code> brackets refers to the name of the variable.  Using the <code>[]</code> brackets refers to value of the variable to be the variable name.  Using the square brackets nested inside brackets, <code>([])</code>, refers the to variable name which can be manipulated.  Use of <code>[[]]</code> refers to the value to the variable name to the value of the variable to be the name of the variable.

<b>For example:</b>

<lang diego>add_var(a);                     // a = undefined variant
add_var({int},b);               // b = undefined integer 

with_var(a)_value(0);           // a = 0 variant
with_var({int},a)_v(1);         // a = 1 integer
with_var([a])_v(2);             // a = 2 integer

with_var[a]_v(3);               
// same as `with_var(3)_v(3);`
// callee will ask `with_var(3)_askdec();`

(a)_v(3);                       // a = 3 integer    // same as `add_var(a)_v(3);`
([a])_v(4);                     // a = 4 integer    // same as `add_var([a])_v(4);`

[a]_v(5);
// same as `with_var(3)_v(5);`
// callee will ask `with_var(3)_askdec();`

(a)_calc([a]+1);                // a = 5

add_var({str},varname)_v(a);
with_var[varname]_v(6);         // a = 6 integer
[varname]_inc();                // a = 7 integer    // same as `with_var(a)_inc();`

with_var([a]+1);                // a = 6 integer
with_var([a]+1)_v(7);           // a = 8 integer

with_var([[varname]]+1);        // a = 9 integer
with_var[[varname]]_inc();      // a = 10 integer
with_var([varname]+1);          // varname = "a1"

with_var({double},a)_v(11);     // a = 11.0 double

(varname)_v(a)_inc(2);          // varname = "c"    // same as `with_var(a)_v(a)_inc(2);`
with_var(varname)_v(b);         // varname = "b"
with_var[varname]_v(0);         // b = 0
([varname])_v(1);               // b = 1            // same as `with_var(b)_v(1);`</lang>

The default reference to a variable using <code>[]</code>, refers to the adjacent variable reading from left to right, regardless of whether the variable is named or unnamed, for example:

<lang diego>alert_human(jo)_msg(Hi [])_str(joeName)_v(Joe);  // Hi Joe

alert_human(gab)_msg(Hi [])_str()_v(Gabriella);  // Hi Gabriella

alert_human(annamarie)_msg(Hi [])_str([a]+'-'[m])_str(a)_v(Anna)_str(m)_v(Marie);  // Hi Anna-Marie
alert_human(annamarie)_msg(Hi []+'-'+[])_str()_v(Anna)_str()_v(Marie);  // Hi Anna-Marie
alert_human(annamarie)_msg(Hi [])_str([]+'-'[])_str()_v(Anna)_str()_v(Marie);  // Hi Anna-Marie</lang>

Inside various posits, such as, <code>_calc</code> or <code>_msg</code>, the square brackets <code>[]</code> are used to escape into variables.  Single quote marks can also be used to escape literals, but are optional.

<b>For example:</b>

<lang diego>alert_human(jill)_msg(Hi [jillName] Daniels)_var(jillName)_value(Jill);  // Hi Jill Daniels
alert_human(jill)_msg('Hi '+[jillName]+' Daniels')_var(jillName)_value(Jill);  // Hi Jill Daniels
add_var(jillFullName)_calc([jillName]+" Daniels");</lang>